{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sentinel-1 SAR Backscatter Analysis Ready Data Preparation in Google Earth Engine","text":"<p>This implementation enhances the Sentinel-1 SAR Backscatter ARD Preparation framework by making it a PyPI package.</p>"},{"location":"#features","title":"Features","text":"Parameter Type Description Default <code>geometry</code> <code>ee.Geometry</code> Area of interest Required <code>start_date</code> <code>str</code> Start date (YYYY-MM-DD) Required <code>stop_date</code> <code>str</code> End date (YYYY-MM-DD) Required <code>polarization</code> <code>str</code> Polarization (<code>VV</code>, <code>VH</code>, <code>VVVH</code>) <code>VVVH</code> <code>apply_border_noise_correction</code> <code>bool</code> Apply border noise correction <code>True</code> <code>apply_terrain_flattening</code> <code>bool</code> Apply terrain flattening <code>True</code> <code>apply_speckle_filtering</code> <code>bool</code> Apply speckle filtering <code>True</code> <code>output_format</code> <code>str</code> Output format (<code>LINEAR</code>, <code>DB</code>) <code>DB</code>"},{"location":"#installation","title":"Installation","text":"<p>Make sure you have the <code>earthengine-api</code> installed:</p> <pre><code>pip install ee-s1-ard\n</code></pre> <p>Authenticate with Google Earth Engine:</p> <pre><code>earthengine authenticate\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#1-import-the-library-and-create-an-instance","title":"1. Import the library and create an instance:","text":"<pre><code>import ee\n\n# Initialize the GEE API\nee.Initialize()\n\nfrom ee-s1-ard import S1ARDImageCollection\n\n# Define input parameters\ngeometry = ee.Geometry.Polygon(\n    [[[5.0, 50.0], [5.5, 50.0], [5.5, 50.5], [5.0, 50.5], [5.0, 50.0]]]\n)\nstart_date = '2021-01-01'\nstop_date = '2021-12-31'\n\nprocessor = S1ARDImageCollection(\n    geometry=geometry,\n    start_date=start_date,\n    stop_date=stop_date,\n    polarization=\"VVVH\",\n    apply_border_noise_correction=True,\n    apply_terrain_flattening=True,\n    apply_speckle_filtering=True,\n    output_format=\"DB\"\n)\n</code></pre>"},{"location":"#2-get-the-processed-collection","title":"2. Get the processed collection:","text":"<pre><code>collection = processor.get_collection()\n</code></pre>"},{"location":"#3-example-display-the-collection-in-gee","title":"3. Example: Display the collection in GEE:","text":"<pre><code>import geemap\n\nMap = geemap.Map()\nMap.centerObject(geometry, 10)\nMap.addLayer(collection.mean(), {'min': -25, 'max': 0}, 'Sentinel-1')\nMap\n</code></pre>"},{"location":"#notes","title":"Notes","text":"<ul> <li>The processed collection is ready for analysis and visualization.</li> <li>Speckle filtering and terrain flattening are optional but improve data quality.</li> <li>Output in dB scale is suitable for most applications. ```</li> </ul>"},{"location":"#why-forking","title":"Why forking?","text":"<p>I DO NOT OWN THE SOLUTION MADE HERE. All credits go to the author and original paper, duly referenced here. My purpose was simply to make the code more pythonic, with checks (mypy), and create a package on Pypi, in order to be easily usable in several academic and production solutions.</p>"},{"location":"#testing-the-solution-in-sits-satellite-image-time-series-for-agriculture","title":"Testing the solution in SITS (Satellite Image Time Series) for agriculture","text":""},{"location":"#testing-the-solution-in-a-single-agriculture-image","title":"Testing the solution in a single agriculture image","text":""},{"location":"#raw-image-from-gee","title":"Raw image (from GEE)","text":""},{"location":"#grd-image-preprocessed-in-gee","title":"GRD image (preprocessed in GEE)","text":""},{"location":"#ard-image-this-solution","title":"ARD image (this solution)","text":""},{"location":"modules/","title":"Modules","text":"<p>Creates an Analysis-Ready Sentinel-1 ImageCollection following the framework described in Mullissa et al. (2021) Remote Sens. 2021, 13, 1954.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Geometry</code> <p>Region of interest for filtering the Sentinel-1 collection.</p> required <code>start_date</code> <code>str</code> <p>Start date for filtering the Sentinel-1 collection (YYYY-MM-DD). See Section 2.1 (Mullissa et al. 2021) for details on data selection.</p> required <code>stop_date</code> <code>str</code> <p>End date for filtering the Sentinel-1 collection (YYYY-MM-DD).</p> required <code>ascending</code> <code>bool</code> <p>Choose between ascending or descending orbit.</p> <code>True</code> <code>polarization</code> <code>str</code> <p>Polarization mode. Options are \"VV\", \"VH\", \"VVVH\". See Section 2.1 for coverage details.</p> <code>\"VVVH\"</code> <code>apply_border_noise_correction</code> <code>bool</code> <p>Whether to remove additional border noise. See Section 2.2.</p> <code>True</code> <code>apply_terrain_flattening</code> <code>bool</code> <p>Whether to apply radiometric terrain normalization. See Section 2.4.</p> <code>True</code> <code>apply_speckle_filtering</code> <code>bool</code> <p>Whether to apply speckle filtering. See Section 2.3.</p> <code>True</code> <code>speckle_filter_framework</code> <code>str</code> <p>Framework for speckle filtering. Options are \"MONO\" or \"MULTI\".</p> <code>\"MULTI\"</code> <code>speckle_filter_type</code> <code>str</code> <p>Type of speckle filter. Options include \"BOXCAR\", \"LEE\", \"GAMMA MAP\", \"REFINED LEE\", \"LEE SIGMA\".</p> <code>\"GAMMA MAP\"</code> <code>speckle_filter_kernel_size</code> <code>int</code> <p>Kernel size used by the speckle filter.</p> <code>7</code> <code>speckle_filter_nr_of_images</code> <code>int</code> <p>Number of images considered in multi-temporal speckle filtering.</p> <code>10</code> <code>terrain_flattening_model</code> <code>str</code> <p>Model for terrain normalization. Options are \"DIRECT\", \"VOLUME\".</p> <code>\"VOLUME\"</code> <code>terrain_flattening_additional_buffer</code> <code>int</code> <p>Additional buffer in meters for layover and shadow masking.</p> <code>0</code> <code>output_format</code> <code>str</code> <p>Output backscatter format. Options are \"LINEAR\" or \"DB\".</p> <code>\"DB\"</code> <code>dem</code> <code>Optional[Image]</code> <p>Digital Elevation Model for terrain normalization. If None, the default SRTM DEM is used.</p> <code>None</code> References <p>Mullissa, A. et al. (2021): Sentinel-1 SAR Backscatter Analysis Ready Data Preparation in Google Earth Engine. Remote Sens. 13(10), 1954.</p> Source code in <code>ee_s1_ard/wrapper.py</code> <pre><code>class S1ARDImageCollection:\n    \"\"\"\n    Creates an Analysis-Ready Sentinel-1 ImageCollection following the framework\n    described in Mullissa et al. (2021) Remote Sens. 2021, 13, 1954.\n\n    Parameters\n    ----------\n    geometry : ee.Geometry\n        Region of interest for filtering the Sentinel-1 collection.\n    start_date : str\n        Start date for filtering the Sentinel-1 collection (YYYY-MM-DD).\n        See Section 2.1 (Mullissa et al. 2021) for details on data selection.\n    stop_date : str\n        End date for filtering the Sentinel-1 collection (YYYY-MM-DD).\n    ascending: bool, default=True\n        Choose between ascending or descending orbit.\n    polarization : str, default=\"VVVH\"\n        Polarization mode. Options are \"VV\", \"VH\", \"VVVH\".\n        See Section 2.1 for coverage details.\n    apply_border_noise_correction : bool, default=True\n        Whether to remove additional border noise. See Section 2.2.\n    apply_terrain_flattening : bool, default=True\n        Whether to apply radiometric terrain normalization. See Section 2.4.\n    apply_speckle_filtering : bool, default=True\n        Whether to apply speckle filtering. See Section 2.3.\n    speckle_filter_framework : str, default=\"MULTI\"\n        Framework for speckle filtering. Options are \"MONO\" or \"MULTI\".\n    speckle_filter_type : str, default=\"GAMMA MAP\"\n        Type of speckle filter. Options include \"BOXCAR\", \"LEE\",\n        \"GAMMA MAP\", \"REFINED LEE\", \"LEE SIGMA\".\n    speckle_filter_kernel_size : int, default=7\n        Kernel size used by the speckle filter.\n    speckle_filter_nr_of_images : int, default=10\n        Number of images considered in multi-temporal speckle filtering.\n    terrain_flattening_model : str, default=\"VOLUME\"\n        Model for terrain normalization. Options are \"DIRECT\", \"VOLUME\".\n    terrain_flattening_additional_buffer : int, default=0\n        Additional buffer in meters for layover and shadow masking.\n    output_format : str, default=\"DB\"\n        Output backscatter format. Options are \"LINEAR\" or \"DB\".\n    dem : Optional[ee.Image], default=None\n        Digital Elevation Model for terrain normalization. If None,\n        the default SRTM DEM is used.\n\n    References\n    ----------\n    Mullissa, A. et al. (2021): Sentinel-1 SAR Backscatter Analysis Ready Data Preparation\n    in Google Earth Engine. Remote Sens. 13(10), 1954.\n    \"\"\"\n\n    def __init__(\n        self,\n        geometry: ee.Geometry,\n        start_date: str,\n        stop_date: str,\n        ascending: bool = True,\n        polarization: str = \"VVVH\",\n        apply_border_noise_correction: bool = True,\n        apply_terrain_flattening: bool = True,\n        apply_speckle_filtering: bool = True,\n        speckle_filter_framework: str = \"MULTI\",\n        speckle_filter_type: str = \"GAMMA MAP\",\n        speckle_filter_kernel_size: int = 7,\n        speckle_filter_nr_of_images: int = 10,\n        terrain_flattening_model: str = \"VOLUME\",\n        terrain_flattening_additional_buffer: int = 0,\n        output_format: str = \"DB\",\n        clip_to_roi: bool = False,\n        save_asset: bool = False,\n        asset_id: str = \"\",\n        dem: str = \"USGS/SRTMGL1_003\",\n    ) -&gt; None:\n        if polarization not in [\"VV\", \"VH\", \"VVVH\"]:\n            raise ValueError(\"Invalid polarization\")  # noqa: TRY003\n        if speckle_filter_framework not in [\"MONO\", \"MULTI\"]:\n            raise ValueError(\"Invalid speckle filter framework\")  # noqa: TRY003\n        if speckle_filter_type not in [\n            \"BOXCAR\",\n            \"LEE\",\n            \"GAMMA MAP\",\n            \"REFINED LEE\",\n            \"LEE SIGMA\",\n        ]:\n            raise ValueError(\"Invalid speckle filter type\")  # noqa: TRY003\n        if terrain_flattening_model not in [\"DIRECT\", \"VOLUME\"]:\n            raise ValueError(\"Invalid terrain flattening model\")  # noqa: TRY003\n        if output_format not in [\"LINEAR\", \"DB\"]:\n            raise ValueError(\"Invalid output format\")  # noqa: TRY003\n        if terrain_flattening_additional_buffer &lt; 0:\n            raise ValueError(\"Buffer must be &gt;= 0\")  # noqa: TRY003\n        if speckle_filter_kernel_size &lt;= 0:\n            raise ValueError(\"Kernel size must be &gt; 0\")  # noqa: TRY003\n\n        self.start_date = start_date\n        self.stop_date = stop_date\n        self.geometry = geometry\n        self.polarization = polarization\n        self.ascending = ascending\n        self.apply_border_noise_correction = apply_border_noise_correction\n        self.apply_terrain_flattening = apply_terrain_flattening\n        self.apply_speckle_filtering = apply_speckle_filtering\n        self.speckle_filter_framework = speckle_filter_framework\n        self.speckle_filter_type = speckle_filter_type\n        self.speckle_filter_kernel_size = speckle_filter_kernel_size\n        self.speckle_filter_nr_of_images = speckle_filter_nr_of_images\n        self.terrain_flattening_model = terrain_flattening_model\n        self.terrain_flattening_additional_buffer = terrain_flattening_additional_buffer\n        self.output_format = output_format\n        self.clip_to_roi = clip_to_roi\n        self.save_asset = save_asset\n        self.asset_id = asset_id\n        self.dem = ee.Image(dem)\n\n    def get_collection(self) -&gt; ee.ImageCollection:\n        \"\"\"\n        Prepares the Sentinel-1 SAR ImageCollection as Analysis-Ready Data (ARD).\n\n        Returns\n        -------\n        ee.ImageCollection\n            Sentinel-1 ARD collection in linear or dB scale.\n        \"\"\"\n        s1 = (\n            ee.ImageCollection(\"COPERNICUS/S1_GRD_FLOAT\")\n            .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n            .filter(ee.Filter.eq(\"resolution_meters\", 10))\n            .filterDate(self.start_date, self.stop_date)\n            .filterBounds(self.geometry)\n        )\n        if self.polarization == \"VV\":\n            s1 = s1.filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))\n            s1 = s1.select([\"VV\", \"angle\"])\n        elif self.polarization == \"VH\":\n            s1 = s1.filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"))\n            s1 = s1.select([\"VH\", \"angle\"])\n        else:\n            s1 = s1.filter(\n                ee.Filter.And(\n                    ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"),\n                    ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"),\n                )\n            )\n            s1 = s1.select([\"VV\", \"VH\", \"angle\"])\n\n        s1 = s1.filter(ee.Filter.eq(\"orbitProperties_pass\", \"ASCENDING\" if self.ascending else \"DESCENDING\"))\n\n        if self.apply_border_noise_correction:\n            s1 = s1.map(bnc.f_mask_edges)\n        if self.apply_speckle_filtering:\n            if self.speckle_filter_framework == \"MONO\":\n                s1 = ee.ImageCollection(\n                    sf.MonoTemporal_Filter(s1, self.speckle_filter_kernel_size, self.speckle_filter_type)\n                )\n            else:\n                s1 = ee.ImageCollection(\n                    sf.MultiTemporal_Filter(\n                        s1,\n                        self.speckle_filter_kernel_size,\n                        self.speckle_filter_type,\n                        self.speckle_filter_nr_of_images,\n                    )\n                )\n        if self.apply_terrain_flattening:\n            s1 = trf.slope_correction(\n                s1,\n                self.terrain_flattening_model,\n                self.dem,\n                self.terrain_flattening_additional_buffer,\n            )\n        if self.output_format == \"DB\":\n            s1 = s1.map(helper.lin_to_db)\n\n        return s1\n</code></pre>"},{"location":"modules/#ee_s1_ard.S1ARDImageCollection.get_collection","title":"<code>get_collection()</code>","text":"<p>Prepares the Sentinel-1 SAR ImageCollection as Analysis-Ready Data (ARD).</p> <p>Returns:</p> Type Description <code>ImageCollection</code> <p>Sentinel-1 ARD collection in linear or dB scale.</p> Source code in <code>ee_s1_ard/wrapper.py</code> <pre><code>def get_collection(self) -&gt; ee.ImageCollection:\n    \"\"\"\n    Prepares the Sentinel-1 SAR ImageCollection as Analysis-Ready Data (ARD).\n\n    Returns\n    -------\n    ee.ImageCollection\n        Sentinel-1 ARD collection in linear or dB scale.\n    \"\"\"\n    s1 = (\n        ee.ImageCollection(\"COPERNICUS/S1_GRD_FLOAT\")\n        .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n        .filter(ee.Filter.eq(\"resolution_meters\", 10))\n        .filterDate(self.start_date, self.stop_date)\n        .filterBounds(self.geometry)\n    )\n    if self.polarization == \"VV\":\n        s1 = s1.filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))\n        s1 = s1.select([\"VV\", \"angle\"])\n    elif self.polarization == \"VH\":\n        s1 = s1.filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"))\n        s1 = s1.select([\"VH\", \"angle\"])\n    else:\n        s1 = s1.filter(\n            ee.Filter.And(\n                ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"),\n                ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"),\n            )\n        )\n        s1 = s1.select([\"VV\", \"VH\", \"angle\"])\n\n    s1 = s1.filter(ee.Filter.eq(\"orbitProperties_pass\", \"ASCENDING\" if self.ascending else \"DESCENDING\"))\n\n    if self.apply_border_noise_correction:\n        s1 = s1.map(bnc.f_mask_edges)\n    if self.apply_speckle_filtering:\n        if self.speckle_filter_framework == \"MONO\":\n            s1 = ee.ImageCollection(\n                sf.MonoTemporal_Filter(s1, self.speckle_filter_kernel_size, self.speckle_filter_type)\n            )\n        else:\n            s1 = ee.ImageCollection(\n                sf.MultiTemporal_Filter(\n                    s1,\n                    self.speckle_filter_kernel_size,\n                    self.speckle_filter_type,\n                    self.speckle_filter_nr_of_images,\n                )\n            )\n    if self.apply_terrain_flattening:\n        s1 = trf.slope_correction(\n            s1,\n            self.terrain_flattening_model,\n            self.dem,\n            self.terrain_flattening_additional_buffer,\n        )\n    if self.output_format == \"DB\":\n        s1 = s1.map(helper.lin_to_db)\n\n    return s1\n</code></pre>"}]}