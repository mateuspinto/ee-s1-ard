{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ee-s1-ard","text":""},{"location":"modules/","title":"Modules","text":"<p>Creates an Analysis-Ready Sentinel-1 ImageCollection following the framework described in Mullissa et al. (2021) Remote Sens. 2021, 13, 1954.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Geometry</code> <p>Region of interest for filtering the Sentinel-1 collection.</p> required <code>start_date</code> <code>str</code> <p>Start date for filtering the Sentinel-1 collection (YYYY-MM-DD). See Section 2.1 (Mullissa et al. 2021) for details on data selection.</p> required <code>stop_date</code> <code>str</code> <p>End date for filtering the Sentinel-1 collection (YYYY-MM-DD).</p> required <code>ascending</code> <code>bool</code> <p>Choose between ascending or descending orbit.</p> <code>True</code> <code>polarization</code> <code>str</code> <p>Polarization mode. Options are \"VV\", \"VH\", \"VVVH\". See Section 2.1 for coverage details.</p> <code>\"VVVH\"</code> <code>apply_border_noise_correction</code> <code>bool</code> <p>Whether to remove additional border noise. See Section 2.2.</p> <code>True</code> <code>apply_terrain_flattening</code> <code>bool</code> <p>Whether to apply radiometric terrain normalization. See Section 2.4.</p> <code>True</code> <code>apply_speckle_filtering</code> <code>bool</code> <p>Whether to apply speckle filtering. See Section 2.3.</p> <code>True</code> <code>speckle_filter_framework</code> <code>str</code> <p>Framework for speckle filtering. Options are \"MONO\" or \"MULTI\".</p> <code>\"MULTI\"</code> <code>speckle_filter_type</code> <code>str</code> <p>Type of speckle filter. Options include \"BOXCAR\", \"LEE\", \"GAMMA MAP\", \"REFINED LEE\", \"LEE SIGMA\".</p> <code>\"GAMMA MAP\"</code> <code>speckle_filter_kernel_size</code> <code>int</code> <p>Kernel size used by the speckle filter.</p> <code>7</code> <code>speckle_filter_nr_of_images</code> <code>int</code> <p>Number of images considered in multi-temporal speckle filtering.</p> <code>10</code> <code>terrain_flattening_model</code> <code>str</code> <p>Model for terrain normalization. Options are \"DIRECT\", \"VOLUME\".</p> <code>\"VOLUME\"</code> <code>terrain_flattening_additional_buffer</code> <code>int</code> <p>Additional buffer in meters for layover and shadow masking.</p> <code>0</code> <code>output_format</code> <code>str</code> <p>Output backscatter format. Options are \"LINEAR\" or \"DB\".</p> <code>\"DB\"</code> <code>dem</code> <code>Optional[Image]</code> <p>Digital Elevation Model for terrain normalization. If None, the default SRTM DEM is used.</p> <code>None</code> References <p>Mullissa, A. et al. (2021): Sentinel-1 SAR Backscatter Analysis Ready Data Preparation in Google Earth Engine. Remote Sens. 13(10), 1954.</p> Source code in <code>ee_s1_ard/wrapper.py</code> <pre><code>class S1ARDImageCollection:\n    \"\"\"\n    Creates an Analysis-Ready Sentinel-1 ImageCollection following the framework\n    described in Mullissa et al. (2021) Remote Sens. 2021, 13, 1954.\n\n    Parameters\n    ----------\n    geometry : ee.Geometry\n        Region of interest for filtering the Sentinel-1 collection.\n    start_date : str\n        Start date for filtering the Sentinel-1 collection (YYYY-MM-DD).\n        See Section 2.1 (Mullissa et al. 2021) for details on data selection.\n    stop_date : str\n        End date for filtering the Sentinel-1 collection (YYYY-MM-DD).\n    ascending: bool, default=True\n        Choose between ascending or descending orbit.\n    polarization : str, default=\"VVVH\"\n        Polarization mode. Options are \"VV\", \"VH\", \"VVVH\".\n        See Section 2.1 for coverage details.\n    apply_border_noise_correction : bool, default=True\n        Whether to remove additional border noise. See Section 2.2.\n    apply_terrain_flattening : bool, default=True\n        Whether to apply radiometric terrain normalization. See Section 2.4.\n    apply_speckle_filtering : bool, default=True\n        Whether to apply speckle filtering. See Section 2.3.\n    speckle_filter_framework : str, default=\"MULTI\"\n        Framework for speckle filtering. Options are \"MONO\" or \"MULTI\".\n    speckle_filter_type : str, default=\"GAMMA MAP\"\n        Type of speckle filter. Options include \"BOXCAR\", \"LEE\",\n        \"GAMMA MAP\", \"REFINED LEE\", \"LEE SIGMA\".\n    speckle_filter_kernel_size : int, default=7\n        Kernel size used by the speckle filter.\n    speckle_filter_nr_of_images : int, default=10\n        Number of images considered in multi-temporal speckle filtering.\n    terrain_flattening_model : str, default=\"VOLUME\"\n        Model for terrain normalization. Options are \"DIRECT\", \"VOLUME\".\n    terrain_flattening_additional_buffer : int, default=0\n        Additional buffer in meters for layover and shadow masking.\n    output_format : str, default=\"DB\"\n        Output backscatter format. Options are \"LINEAR\" or \"DB\".\n    dem : Optional[ee.Image], default=None\n        Digital Elevation Model for terrain normalization. If None,\n        the default SRTM DEM is used.\n\n    References\n    ----------\n    Mullissa, A. et al. (2021): Sentinel-1 SAR Backscatter Analysis Ready Data Preparation\n    in Google Earth Engine. Remote Sens. 13(10), 1954.\n    \"\"\"\n\n    def __init__(\n        self,\n        geometry: ee.Geometry,\n        start_date: str,\n        stop_date: str,\n        ascending: bool = True,\n        polarization: str = \"VVVH\",\n        apply_border_noise_correction: bool = True,\n        apply_terrain_flattening: bool = True,\n        apply_speckle_filtering: bool = True,\n        speckle_filter_framework: str = \"MULTI\",\n        speckle_filter_type: str = \"GAMMA MAP\",\n        speckle_filter_kernel_size: int = 7,\n        speckle_filter_nr_of_images: int = 10,\n        terrain_flattening_model: str = \"VOLUME\",\n        terrain_flattening_additional_buffer: int = 0,\n        output_format: str = \"DB\",\n        clip_to_roi: bool = False,\n        save_asset: bool = False,\n        asset_id: str = \"\",\n        dem: str = \"USGS/SRTMGL1_003\",\n    ) -&gt; None:\n        if polarization not in [\"VV\", \"VH\", \"VVVH\"]:\n            raise ValueError(\"Invalid polarization\")\n        if speckle_filter_framework not in [\"MONO\", \"MULTI\"]:\n            raise ValueError(\"Invalid speckle filter framework\")\n        if speckle_filter_type not in [\n            \"BOXCAR\",\n            \"LEE\",\n            \"GAMMA MAP\",\n            \"REFINED LEE\",\n            \"LEE SIGMA\",\n        ]:\n            raise ValueError(\"Invalid speckle filter type\")\n        if terrain_flattening_model not in [\"DIRECT\", \"VOLUME\"]:\n            raise ValueError(\"Invalid terrain flattening model\")\n        if output_format not in [\"LINEAR\", \"DB\"]:\n            raise ValueError(\"Invalid output format\")\n        if terrain_flattening_additional_buffer &lt; 0:\n            raise ValueError(\"Buffer must be &gt;= 0\")\n        if speckle_filter_kernel_size &lt;= 0:\n            raise ValueError(\"Kernel size must be &gt; 0\")\n\n        self.start_date = start_date\n        self.stop_date = stop_date\n        self.geometry = geometry\n        self.polarization = polarization\n        self.ascending = ascending\n        self.apply_border_noise_correction = apply_border_noise_correction\n        self.apply_terrain_flattening = apply_terrain_flattening\n        self.apply_speckle_filtering = apply_speckle_filtering\n        self.speckle_filter_framework = speckle_filter_framework\n        self.speckle_filter_type = speckle_filter_type\n        self.speckle_filter_kernel_size = speckle_filter_kernel_size\n        self.speckle_filter_nr_of_images = speckle_filter_nr_of_images\n        self.terrain_flattening_model = terrain_flattening_model\n        self.terrain_flattening_additional_buffer = terrain_flattening_additional_buffer\n        self.output_format = output_format\n        self.clip_to_roi = clip_to_roi\n        self.save_asset = save_asset\n        self.asset_id = asset_id\n        self.dem = ee.Image(dem)\n\n    def get_collection(self) -&gt; ee.ImageCollection:\n        \"\"\"\n        Prepares the Sentinel-1 SAR ImageCollection as Analysis-Ready Data (ARD).\n\n        Returns\n        -------\n        ee.ImageCollection\n            Sentinel-1 ARD collection in linear or dB scale.\n        \"\"\"\n        s1 = (\n            ee.ImageCollection(\"COPERNICUS/S1_GRD_FLOAT\")\n            .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n            .filter(ee.Filter.eq(\"resolution_meters\", 10))\n            .filterDate(self.start_date, self.stop_date)\n            .filterBounds(self.geometry)\n        )\n        if self.polarization == \"VV\":\n            s1 = s1.filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))\n            s1 = s1.select([\"VV\", \"angle\"])\n        elif self.polarization == \"VH\":\n            s1 = s1.filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"))\n            s1 = s1.select([\"VH\", \"angle\"])\n        else:\n            s1 = s1.filter(\n                ee.Filter.And(\n                    ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"),\n                    ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"),\n                )\n            )\n            s1 = s1.select([\"VV\", \"VH\", \"angle\"])\n\n        s1 = s1.filter(ee.Filter.eq(\"orbitProperties_pass\", \"ASCENDING\" if self.ascending else \"DESCENDING\"))\n\n        if self.apply_border_noise_correction:\n            s1 = s1.map(bnc.f_mask_edges)\n        if self.apply_speckle_filtering:\n            if self.speckle_filter_framework == \"MONO\":\n                s1 = ee.ImageCollection(\n                    sf.MonoTemporal_Filter(s1, self.speckle_filter_kernel_size, self.speckle_filter_type)\n                )\n            else:\n                s1 = ee.ImageCollection(\n                    sf.MultiTemporal_Filter(\n                        s1,\n                        self.speckle_filter_kernel_size,\n                        self.speckle_filter_type,\n                        self.speckle_filter_nr_of_images,\n                    )\n                )\n        if self.apply_terrain_flattening:\n            s1 = trf.slope_correction(\n                s1,\n                self.terrain_flattening_model,\n                self.dem,\n                self.terrain_flattening_additional_buffer,\n            )\n        if self.output_format == \"DB\":\n            s1 = s1.map(helper.lin_to_db)\n\n        return s1\n</code></pre>"},{"location":"modules/#ee_s1_ard.S1ARDImageCollection.get_collection","title":"<code>get_collection()</code>","text":"<p>Prepares the Sentinel-1 SAR ImageCollection as Analysis-Ready Data (ARD).</p> <p>Returns:</p> Type Description <code>ImageCollection</code> <p>Sentinel-1 ARD collection in linear or dB scale.</p> Source code in <code>ee_s1_ard/wrapper.py</code> <pre><code>def get_collection(self) -&gt; ee.ImageCollection:\n    \"\"\"\n    Prepares the Sentinel-1 SAR ImageCollection as Analysis-Ready Data (ARD).\n\n    Returns\n    -------\n    ee.ImageCollection\n        Sentinel-1 ARD collection in linear or dB scale.\n    \"\"\"\n    s1 = (\n        ee.ImageCollection(\"COPERNICUS/S1_GRD_FLOAT\")\n        .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n        .filter(ee.Filter.eq(\"resolution_meters\", 10))\n        .filterDate(self.start_date, self.stop_date)\n        .filterBounds(self.geometry)\n    )\n    if self.polarization == \"VV\":\n        s1 = s1.filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))\n        s1 = s1.select([\"VV\", \"angle\"])\n    elif self.polarization == \"VH\":\n        s1 = s1.filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"))\n        s1 = s1.select([\"VH\", \"angle\"])\n    else:\n        s1 = s1.filter(\n            ee.Filter.And(\n                ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"),\n                ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VH\"),\n            )\n        )\n        s1 = s1.select([\"VV\", \"VH\", \"angle\"])\n\n    s1 = s1.filter(ee.Filter.eq(\"orbitProperties_pass\", \"ASCENDING\" if self.ascending else \"DESCENDING\"))\n\n    if self.apply_border_noise_correction:\n        s1 = s1.map(bnc.f_mask_edges)\n    if self.apply_speckle_filtering:\n        if self.speckle_filter_framework == \"MONO\":\n            s1 = ee.ImageCollection(\n                sf.MonoTemporal_Filter(s1, self.speckle_filter_kernel_size, self.speckle_filter_type)\n            )\n        else:\n            s1 = ee.ImageCollection(\n                sf.MultiTemporal_Filter(\n                    s1,\n                    self.speckle_filter_kernel_size,\n                    self.speckle_filter_type,\n                    self.speckle_filter_nr_of_images,\n                )\n            )\n    if self.apply_terrain_flattening:\n        s1 = trf.slope_correction(\n            s1,\n            self.terrain_flattening_model,\n            self.dem,\n            self.terrain_flattening_additional_buffer,\n        )\n    if self.output_format == \"DB\":\n        s1 = s1.map(helper.lin_to_db)\n\n    return s1\n</code></pre>"}]}